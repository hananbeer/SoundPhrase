<!doctype html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Soundphrase</title>
        <meta name="description" content="Soundphrase replaces seedphrases - with music!" />
        <meta name="author" content="high_byte" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <meta name="title" content="Soundphrase">
        <meta name="description" content="Soundphrase replaces seedphrases - with music!">

        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:url" content="https://sign-pixels.hanan.beer/">
        <meta property="og:title" content="Sign your avatar!">
        <meta property="og:description" content="Prove your identity easily with a signed avatar">
        <meta property="og:image" content="https://soundphrase.hanan.beer/ogimage.png">

        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="https://sign-pixels.hanan.beer/">
        <meta property="twitter:title" content="Sign your avatar!">
        <meta property="twitter:description" content="Prove your identity easily with a signed avatar">
        <meta name="twitter:image" content="https://soundphrase.hanan.beer/ogimage.png">

        <!-- <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet" /> -->
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
      <br /><br /><br />
        <div class="container">
            <h2>Soundphrase</h2>

            <div style="margin-bottom: 10px">
                <input type="button" value="Sign" onclick="onSign()" />
                <input type="button" value="Download" onclick="onDownload()" />
                <!-- <input type="button" value="Upload" onclick="onUpload()" id="el_upload" /> -->
                <input id="el_upload" type="file" accept="application/json" name="files[]" size="30">

                <input id="el_play" type="button" value="Play" onclick="el_play.classList.toggle('play_notification', false); onPlay()" style="transition: 1s ease" />
                <input type="button" value="Clear" onclick="onClear()" />
                <a id="a_download" style="display: none" download="Soundphrase.json"></a>
            </div>
            <div id="keyboard"></div><br />

            <p id="live_input" style="margin: 0px; width: 500px; height: 20px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; direction: rtl; text-align: center">
            </p>

            <p id="el_priv" class="private" style="writing-mode: vertical-rl; margin: 5px; width: 460px; text-align: center; word-break: break-all; height: 40px;" onclick="el_priv.classList.toggle('private')"></p>
            <p id="el_addr" style="width: 500px; text-align: center; word-break: break-all; height: 20px; margin: 5px;"></p>
            <textarea id="el_msg" rows="10" cols="80">Message to sign...</textarea>
            <p id="el_signature" style="width: 360px; text-align: center; word-break: break-all; height: 80px;"></p>

            <p>
                <img src="/verify.png" id="img_verify" style="visibility: hidden; width: 500px; position: relative; margin-top: -200px; z-index: 999" onclick="img_verify.style['visibility'] = 'hidden'" />
                <br />
                <a href="https://etherscan.io/verifiedSignatures" target="_blank">verify sig</a> <span onmouseover="img_verify.style['visibility'] = 'visible'" onmouseout="img_verify.style['visibility'] = 'hidden'">(?)</span><br />
            </p>

            <p style="width: 500px">
                tip: don't record your Soundphrase on a hot storage like your SSD drive, disk-on-key or the cloud!
                <br /><br />
                use cold storage like a vinyl record.
            </p>

            <p><a href="http://twitter.com/high_byte">@high_byte</a></p>
        </div>
        <script src="lib/ethers.esm.js" type="module"></script>
        <script src="lib/qwerty-hancock.js"></script>
        <script>
            let replaying_idx = -1
            let keys_over_time = []
            let wallet = null
            function makeWallet() {
                let prevTime = 0
                let keysList = []
                let idx = 0
                const cutoff = 50 // ms
                for (let i = 0; i < keys_over_time.length; i++) {
                    let { note, time } = keys_over_time[i]
                    let delta = time - prevTime
                    if (idx > 0 && delta < cutoff) {
                        keysList[idx-1].push(note)
                    } else {
                        keysList[idx] = [note]
                        idx++
                    }
                    prevTime = time
                }
                let keysPreimage = keysList.map((chord) => chord.sort().join(':')).join(',')
                let key = _ethers.utils.solidityKeccak256(['string'], [keysPreimage])
                wallet = new _ethers.Wallet(key)
            }
            
            // time minus some offset for compression
            function getTime() {
                return Date.now() - 1675448170000
            }

            function onSign(e) {
                makeWallet()

                el_addr.innerText = ''
                el_priv.innerText = ''
                el_signature.innerText = ''

                let count = (Math.random() * 5 + 1) || 0;
                let delay = (Math.random() * 300 + 300) || 0;
                for (let i = 0; i < count; i++) {
                    setTimeout(applySignEffects, delay * i)
                }

                setTimeout(onSignComplete, delay * count + 500)
            }

            function onDownload() {
                let json = JSON.stringify(keys_over_time)
                let blob = new Blob([json], {type: "octet/stream"})
                let url = window.URL.createObjectURL(blob)
                a_download.href = url
                a_download.click()
                window.URL.revokeObjectURL(url)
            }

            function onUpload(evt) {
                let files = evt.target.files; // FileList object

                // use the 1st file from the list
                let f = files[0];
                
                let reader = new FileReader();

                // Closure to capture the file information.
                reader.onload = (e) => {
                    keys_over_time = JSON.parse(e.target.result)
                    document.location.hash = '#' + btoa(compressKeys(keys_over_time))

                    live_input.innerText = keys_over_time.map((key) => key.note).join(' ')
                }

                // Read in the image file as a data URL.
                reader.readAsText(f);
            }

            document.getElementById('el_upload').addEventListener('change', onUpload, false);

            function onPlay() {
                // also shit code
                if (++replaying_idx >= keys_over_time.length) {
                    return
                }

                document.getElementById('keyboard').style['pointer-events'] = 'none'

                // let offset = keys_over_time[0].time
                let { note, time, endTime } = keys_over_time[replaying_idx]
                let el_note = document.getElementById(note)
                triggerMouseEvent(el_note, 'mousedown')
                setTimeout(() => {
                    triggerMouseEvent(el_note, 'mouseup')

                    if (replaying_idx + 1 >= keys_over_time.length) {
                        document.getElementById('keyboard').style['pointer-events'] = ''
                        replaying_idx = -1
                    }
                }, endTime - time)
                
                if (replaying_idx + 1 >= keys_over_time.length) {
                    return
                }

                let nextTime = keys_over_time[replaying_idx + 1].time
                setTimeout(() => onPlay(time), nextTime - time)
            }

            function onClear() {
                // reset only if starting to play again
                el_signature.innerText = ''
                live_input.innerText = ''
                keys_over_time = []
                replaying_idx = -1
                document.getElementById('keyboard').style['pointer-events'] = ''
                document.location.hash = '#'
            }

            function onSignComplete() {
                // remove applied effects
                el_msg.style['transform'] = ''
                el_msg.style['filter'] = ''
                el_msg.style['background-color'] = ''
                el_msg.style['border-color'] = ''

                // actually sign now
                wallet.signMessage(el_msg.value).then((sig) => {
                    el_addr.innerText = wallet.address
                    el_priv.innerText = wallet.privateKey
                    el_signature.innerText = sig
                })
            }

            // scale x, scale y, rotate x, rotate y, rotation degrees / 720, red, green, blue, saturation
            let transforms = [1, 1, 0, 0, 1, 1, 1, 1, 1]
            function applySignEffects() {
                for (let i = 0; i <transforms.length; i++) {
                    transforms[i] += 1.5 * (Math.random() - 0.5);
                    if (transforms[i] < -1)
                        transforms[i] = -1
                    else if (transforms[i] > 1)
                        transforms[i] = 1
                }
            
                let [sx, sy, rx, ry, deg, r, g, b, sat] = transforms
                el_msg.style['transform'] = `scale(${sx * 1 + 0.5}, ${sy * 1 + 0.5}) rotate3d(${rx + 1}, ${ry + 1}, 0, ${deg * 720}deg)`
                //el_msg.style['background-color'] = `rgb(${r * 255}, ${r * 255}, ${b * 255})`
                el_msg.style['border-color'] = `rgb(${255 - r * 255}, ${255 - g * 255}, ${255 - b * 255})`
                //el_msg.style['filter'] = `contrast(${sat + 1})`
            }

            window.AudioContext = window.AudioContext || window.webkitAudioContext;

            var context = new AudioContext(),
            settings = {
                id: 'keyboard',
                width: 500,
                height: 150,
                startNote: 'B2',
                margin: '0px',
                whiteNotesColour: '#fff',
                blackNotesColour: '#000',
                borderColour: '#000',
                activeColour: 'yellow',
                octaves: 2,
                musicalTyping: false
            },
            keyboard = new QwertyHancock(settings);
            
            function triggerMouseEvent(node, eventType) {
                var clickEvent = document.createEvent('MouseEvents');
                clickEvent.initEvent(eventType, true, true);
                node.dispatchEvent(clickEvent);
            }

            var isModifierKey = function (e) {
                return e.ctrlKey ||  e.metaKey || e.altKey;
            };

            let key_map = {
                'a': 'B2',
                's': 'C3',
                'd': 'D3',
                'f': 'E3',
                'g': 'F3',
                'h': 'G3',
                'j': 'A3',
                'k': 'B3',
            }

            window.addEventListener('keydown', function (e) {
                if (isModifierKey(e) || e.target == el_msg)
                    return;

                note = key_map[e.key]
                if (note) {
                    triggerMouseEvent(document.getElementById(note), 'mousedown')
                }
            })

            window.addEventListener('keyup', function (e) {
                if (isModifierKey(e) || e.target == el_msg)
                    return;
                
                note = key_map[e.key]
                if (note)
                    triggerMouseEvent(document.getElementById(note), 'mouseup')
            })

            masterGain = context.createGain();
            nodes = {};

            masterGain.gain.value = 0.3;
            masterGain.connect(context.destination);

            function compressKeys(keys) {
                if (keys.length == 0)
                    return ''

                let offset = keys[0].time
                let data = []
                for (let key of keys) {
                    data.push(`${key.note}:${key.time-offset}:${key.endTime-offset}`)
                }

                return data.join(',')
            }

            function uncompressKeys(data) {
                let keys = []

                for (let key of data.split(',')) {
                    let [note, time, endTime] = key.split(':')
                    time = parseInt(time)
                    endTime = parseInt(endTime)
                    keys.push({ note, time, endTime })
                }

                return keys
            }

            keyboard.keyDown = function (note, frequency) {
                if (nodes[note])
                    return

                let oscillator = context.createOscillator();
                //oscillator.type = 'sine';
                oscillator.frequency.value = frequency;

                let real = new Float32Array([0.9,0,1,0,2,0,3,0,0,0,0.9])
                let imag = new Float32Array(real.length)
                let customWave = context.createPeriodicWave(real, imag)
                oscillator.setPeriodicWave(customWave);

                oscillator.connect(masterGain);
                oscillator.start(0);

                nodes[note] = oscillator;

                if (!(replaying_idx >= 0)) {
                    if (el_signature.innerText.length > 0) {
                        onClear()
                    }

                    live_input.innerText += ' ' + note

                    keys_over_time.push({ note, time: getTime() })
                    document.location.hash = '#' + btoa(compressKeys(keys_over_time))
                }
            };

            keyboard.keyUp = function (note, frequency) {
                // shit code but it's last minute hack for replaying stuff :\
                if (!(replaying_idx >= 0)) {
                    let i = keys_over_time.length - 1
                    while (keys_over_time[i].note != note)
                        i--
                    keys_over_time[i].endTime = getTime()
                }

                let osc = nodes[note]
                delete nodes[note]
                
                setTimeout(() => { osc.stop(0); osc.disconnect(); }, 200)
            };

            function loadFromHash() {
                let b64 = document.location.hash.substr(1)
                if (b64) {
                    keys_over_time = uncompressKeys(atob(b64))
                    live_input.innerText = keys_over_time.map((key) => key.note).join(' ')
                    el_play.classList.toggle('play_notification', true)
                }
            }

            window.addEventListener('load', loadFromHash)
            // window.addEventListener('hashchange', loadFromHash)
        </script>
    </body>
</html>
